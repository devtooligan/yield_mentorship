// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4;

import "@yield-protocol/utils-v2/contracts/token/IERC20.sol";
import "./AMMCore.sol";

import "hardhat/console.sol";

struct TokenData {
    IERC20 token;
    uint256 reserve;
}

struct Tokens {
    TokenData x;
    TokenData y;
}


/// @title AMMRouter
/// @author devtooligan.eth
/// @notice Simple Automated Market Maker - Router contract. An excercise for the Yield mentorship program
/// @dev Uses AMMCore
contract AMMRouter {
    AMMCore public core;
    address public owner;

    modifier isInitialized() {
        require(core.k() > 0, "Not initialized");
        _;
    }

    constructor(AMMCore _core) {
        owner = msg.sender;
        core = _core;
    }

    // @notice Use this function to initialize k and add liquidity
    // @dev Can only be used once
    // @param wadX The amount of tokenX to add
    // @param wadY The amount of tokenY to add
    function init(uint256 wadX, uint256 wadY) external {
        require(msg.sender == owner, "Unauthorized");
        require(core.k() == 0, "Already initialized");
        require(wadX > 0 && wadY > 0, "Invalid amounts");
        TokenData storage x = core.tokens();
        TokenData memory y = core.tokens()[1];
        x.token.transferFrom(owner, address(core), wadX);
        y.token.transferFrom(owner, address(core), wadY);
        core._init(msg.sender);
    }

    // @notice Use this function to add liquidity in the correct ratio, receive LP tokens
    // @param wadX The amount of tokenX to add
    // @param wadY The amount of tokenY to add
    function mint(uint256 wadX, uint256 wadY) external isInitialized {
        require(wadX > 0 && wadY > 0, "Invalid amounts");
        (TokenData memory x, TokenData memory y) = core.tokens();
        require((x.reserve / y.reserve) == (wadX / wadY), "Invalid amounts");

        x.token.transferFrom(msg.sender, address(core), wadX);
        y.token.transferFrom(msg.sender, address(core), wadY);
        core._mintLP(msg.sender);
    }

    // @notice Use this function to remove liquidity and get back tokens
    // @param wad The amount of LP tokens to burn
    function burn(uint256 wad) external isInitialized {
        require(wad > 0, "Invalid amount");
        require(core.balanceOf(msg.sender) >= wad, "Insufficent balance");
        core._burnLP(msg.sender, wad);
    }

    // @notice Use this function to sell an exact amount of tokenX for the going rate of tokenY
    // @param _name The amount of tokenX to sell
    function sellX(uint256 wad) external isInitialized {
        require(wad > 0, "Invalid amount");
        (TokenData memory x, ) = core.tokens();
        x.token.transferFrom(msg.sender, address(core), wad);
        core._swapX(msg.sender);
    }

    // @notice Use this function to sell an exact amount of tokenY for the going rate of tokenY
    // @param _name The amount of tokenY to sell
    function sellY(uint256 wad) external isInitialized {
        require(wad > 0, "Invalid amount");
        (, TokenData memory y) = core.tokens();
        y.token.transferFrom(msg.sender, address(core), wad);
        core._swapY(msg.sender);
    }
}
